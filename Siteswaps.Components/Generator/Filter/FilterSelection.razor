@using Siteswaps.Components.Generator.State
@inherits FluxorComponent
@inject IDispatcher _dispatcher
@inject IState<SiteswapGeneratorState> _state
<div class="container">
    <div class="row">
        <div class="col-sm">
            <label for="filterSelect">Select Filter</label>
            <select id="filterSelect" class="custom-select" value="@Value?.FilterType" @onchange="SelectionChanged">
                <option disabled selected value> -- select an option -- </option>
                @foreach (var filter in KnownFilters)
                {
                    <option value="@filter.Key">@filter.Key</option>
                }
            </select>
        </div>
    </div>

    @if (Value is not null)
    {
        <div class="row">
            <DynamicComponent Type="@MapFilterInformationToRenderType(Value)" Parameters="@Parameters(Value)"></DynamicComponent>
            <div class="col-md-3">
                <button type="button" class="btn-primary " @onclick="OnClick">Add</button>
            </div>
        </div>
    }
</div>


@code {

    [Parameter]
    public IFilterInformation? Value { get; set; }

  

    private void SelectionChanged(ChangeEventArgs eventArgs)
    {
        Value = null;
        if (Enum.TryParse(eventArgs.Value?.ToString(), out FilterType yeah))
        {
            Value = KnownFilters.Single(x => x.Key == yeah).Default();
        }
    }

    private void OnClick()
    {
        if (Value is not null)
        {
            _dispatcher.Dispatch(new NewFilterCreatedAction(Value));
        }
    }
    private IDictionary<string, object> Parameters(IFilterInformation information) => new Dictionary<string, object>()
    {
        {"Value", information}
    };

    private Type MapFilterInformationToRenderType(IFilterInformation filterInformation) => KnownFilters.Single(x => x.Key == filterInformation.FilterType).ViewType;

    private List<SiteswapGeneratorState.FilterRendererMap> KnownFilters => _state.Value.KnownFilters;

}